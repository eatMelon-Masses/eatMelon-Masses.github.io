---
layout: post
title:  "grpc原理"
date:   2021-02-01 09:29:59 +0800
categories: grpc
tag: grpc
---

* content
{:toc}

# grpc 原理

## 什么是grpc
    RPC的语义是远程过程调用，在一般的印象中，就是将一个服务调用封装在一个本地方法中，让调用者像使用本地方法一样调用服务，对其屏蔽实现细节。而具体的实现是通过调用方和服务方的一套约定，基于TCP长连接进行数据交互达成。

### 三个特点
   1.需要实现约定调用语义（接口语法）
   2.需要网络传输
   3.需要约定网络传输中的内容格式


# rpc解决方案
1. one rpc是相对早起的rpc解决方案，通过外部数据表示法 来约定数据的压缩方式。

2. RESTfull http json
    restfull 是一种资源状态转换的架构风格，也可以用来实现rpc，互联网对http超广泛的支持，使得这详单简单，也是大多数情况下首选
    通过http协议来进行内容传输，header用来约定编码、body大小等，彼此以\r\n来分割， header和body之间通过两个连续的\r\n分割。

    通过url和对应的参数来标示要调用的方案和参数。

    缺点：
      1.http的header和json的数据冗余和低价压缩率使得传输性能差
      2.json难以表达复杂的参数类型，如结构体等

3. grpc HTTP2.0 Protobuf

    优势：
     1. protobuf进行数据编码，提高数据压缩率
     2. 使用http2.0弥补了http1.1的不足
     3. 同样在调用方和服务方使用协议约定文件，提供参数可选，为版本兼容留下缓冲空间

     http1.1 与http2.0对比
     http1.1虽然引入了keepalive复用tcp连接
      1. 请求是串行执行
      2. 每次都要发送比比要header
      3. 不能双向通信

    http2.0解决思路
      1. 建立header索引表 分动态表和静态表
      2. 建立虚拟通道，解决串行和队首阻塞问题
 
 ## 如何用Protobuf组织内容
 ### 目标是什么
    一般的低流量场景，无须多考虑这些，因为远不会打满cpu或触及带宽上限。但是在高流量的环境下，这个点就会变得非常致命，一波10W的qps可能会将带宽瞬间打满，然后直接堵住，cpu的消耗也需要更多的机器，这些都会直接拉高接口耗时。
    
     protobuf呢？ 输出是一段人眼无法理解的二进制串，里面：

     去掉了字段名，转而以字段标号替代，通过标号可以在proto中找到字段名
     没有类型字符等
     用二进制表达内容，不会将数字转成字符串
     字段值按顺序依次排列

 ## http2.0 优势

    HTTP2 未改变HTTP的语义(如GET/POST等)，只是在传输上做了优化
    引入帧、流的概念，在TCP连接中，可以区分出多个request/response
    一个域名只会有一个TCP连接，借助帧、流可以实现多路复用，降低资源消耗
    引入二进制编码，降低header带来的空间占用
    核心分为头部压缩和多路复用。这两个点都服务于更快的传输、更低资源消耗 这两个目标。

    传输header采用获取码表的，在大量的请求环境下，可以明显降低传输内容。
    支持动态地在表中增加header

## grcp框架如何赋能分布式系统

### 适应能力

#### 服务发现

1. 服务发现协议

    scheme 表示要使用的名称系统，例如DNS，或一套自己的服务发现系统，例如ectd、Eureka、consul，或任意自研服务发现系统的名字。
    authority 表示一些特定于方案的引导信息，例如对于DNS
    authority可以提供一个解析endpoint_name的地址，相当于DNS服务器。(一般在DNS模式下才有用)
    endpoint_name 表示一个服务的具体名字。例如 login-service 
    例如：使用dns时，B服务的地址可以设计为：dns://somedns.com/addrOfServerB，B服务通过dns这种名称系统来发现，B具体轮询somedns.com得知

